//***************************** Lethe Language *********************************
//
// Whitespace is ignored but the noun definition needs to start on a new line.
// Otherwise you can use whitespace to help readability.
//
// ******** Noun Definition ********** [<>] [<[]>]
//
// [<noun>] - this delimates noun definition blocks, starts on a new line.
// Keywords can't start with numbers (1noun) but may contain numbers and spaces.
// Use alphanumeric characters. Nouns need to have unique names.
//
// Nouns are Case *Sensitive*!
//
// [<noun[pattern]>] - sets the pattern to use for this definition.
// Patterns get prepended and every occurance of the pattern string gets
// replaced with the noun string of the noun using the pattern.
//
// [<[pattern]>] - this defines a pettern (sorry for the forest of brackets).
// They are not evaluated and need to be defined before they are used.
// They are essentially macros that get prepended to a noun deifnition.
//
// ******** Values ******************* [<> = ]
//
// [<noun> = value1, value2, #9] - sets the initial values of the noun.
// (in the initial assignment, you can't force noun evaluation with @)
//
// prepend integers with #, there can only ever be one integer value.
// [<noun> = #1, #7, #8] - will set it to 8.
//
// 0 is the default. The integer value doesn't count as a regular text value.
// if no # is used then the number is treated as text.
//
// ******** Verb Definition ********** [:]
//
// [:verb] - past this is where execution goes when you choose this verb.
// [:verb1] [:verb2] - only the first one is visible but both work.
// [:visible verb name[real verb name]] - the visible name may be different.
// [:[real verb name]] - leaving the visible name blank will make the verb
//                       hidden from the list.
//
// You can have mutiple verb definitions of the same name.
// First one with true top level condition will activate upon being called.
//
// ******** Conditions *************** [?@]
//
// [?value1 += value2] - value1 contains value2.
// [?value1 -= value2] - value1 doesn't cantain value2.
// [?value1 = value2] - value1 contains value2 and nothing else.
//
// [?= value2] - noun is implied here (noun being defined).
// In case of an impied noun it will expand to @noun and/or #noun
// based on the contents of the expression on the right.
//
// These will try to compare the integer value of a:
// [?#a = #4] [?#a <= #5] [?#a >= #2] [?#a < #4] [?#a > #8]
//
// If no comparison is present it will return true if it has any contents.
// [?#value1] - returns true if integer greater than 0 or has text values.
//
// Conditions may be placed above verb definitions. They will work by
// hiding the verb if the condition is not met.
//
// ******** Intructions ************** [!]
//
// [!b:verb] - go to and execute [b:verb], return and continue.
//
// Assignment instructions:
// [!noun += value] - add value to noun.
// [!noun -= value] - remove value from noun.
// [!noun = value] - set values of noun to value (removes previous values).
// [!= value] - missing noun defaults to the one beying defined.
// [!noun=] - delete all values of noun (except the integer value).
// [!noun = #0] - set the integer value of noun to 0.
//
// What is on the left side is the name of the noun you want to assign to.
// Using @ might not work as you expect as @noun will evaluate to its values.
// [!@noun = value] - will not assign value to noun. It will assign value to
// nouns with names that match existing values of noun.
//
// Instructions need to be below a verb definition.
//
// ******** Evaluation ***************  @ #
//
// #noun evaluates to integer, @noun to string values of the noun.
// [!noun = string] - assign noun a the value string.
// [!noun1 = @noun2] - assign to noun1 values of noun2.
// [!noun1 = #noun2] - assign the integer of noun1 the integer value of noun2.
// If letters follow # it's a noun becuase nouns can't start with digits.
//
// Numbers are handled wholly seperate so if you wanted to copy both strings
// and the integer value from b to a you would need to explicitly say:
// [!a = @b + #b]
//
// You can also use evaluation in a verb instruction:
// [!@noun1:@noun2] - this will go to noun1_value:noun2_value.
// If there are multiple values it will execute them all in sequence.
//
// You can nest @ evaluations:
// [!@@noun1:verb] - will go to noun3:verb, if noun1 has a value called noun2
//                   and there is a noun2 that has a value called noun3.
//
// ******** Arithmetic *************** ( ) - + * /
//
// You can do arithmetic operations on numbers with + - / * ( ).
//
// You can also add and subtract text values.
// Multiplying text values concatenates them.
// Dividing text values returns values present in both values.
//
// Let's assume we have two nouns defined like so:
// [<noun1> = A, C]
// [<noun2> = B, C]
// Then the following statements are all true
// [?@noun1 = A + C].
// [?@noun1 * @noun2 = AB + AC + CB + CC].
// [?@noun1 / @noun2 = C].
//
// Order of operations is left to right regardless of type so if you need
// a different order of evaluation you can use parenthesis.
//
// ******** Code blocks ************** { } & | [!<<]
//
// {} are used for blocks. If no {} are used the code block is up to next
// condition. Implied block of a top level condition (condition above verb)
// ends with the next top level condition.
//
// [] & [] series of conditions (will short circuit, first negative hit stops).
// [] | [] series of conditions (will short circuit, first positive hit stops).
// (Don't mix ! and ? within these series, results are undefined.)
//
// [!<<] - breaks out of the current and parent block.
// [!<<<] - breaks up three levels up (and so on, add more <).
// Note that a single < as in [!<] is illegal (and would be pointless).
//
// ******** Printing text ************ \n text <keyword>
//
// Text written outside of [ ] will be printed to the screen. Text needs to be
// placed under a verb definition.
//
// Text can contain <keywords> inlined with text. Clicking creats a menu with
// a list of possiblee verbs the user can click on.
// <visual name[real name]> - keyword for the noun [<real name>].
// <name> - keyword where the visual and real name are the same.
// <name[noun:verb]> - keyword which acts immediately when clicked (no menu).
//
// Newlines are considered whitespace and replaced with a space before the
// next line. You can force a newline to be retained by using \n in text.
//
// Whitespace around newlines is ignored so you can indent text in the file.
// You can use the escape character \ to ignore that and force whitespaces.
//
// Reserved characters that need to be escaped with \ in text are:
// < > [ ] { } \ & | //
// & and | will work unescaped but will contract whitespace around them.
// A combination of two / is used for comments so you'll have to escape one
// if you want to use // in text.
//
// All other characters are legal and only treated as special characters
// if within [ ].
//
// ******** Special noun names ******* [<story>]
//
// These nouns are treated differently by the reader (not all are required):
// BEGIN, PLACE, EXITS, NOUNS, CALLS, QUICK
//
// [<BEGIN>] - how the story starts, expects noun:verb (this is essential).
//
// [<PLACE>] - where we are.
// [<EXITS>] - where we can go.
//
// [<NOUNS>] - a noun must be here to remain clickable in the main pane.
//             text from the previous action will lose keywords unless they
/              are here.
// [<QUICK>] - expects values of noun:verb that will print the quick menu.
//             Values here don't need to be in NOUNS to remain clickable.
//
// [<CALLS>] - expects values of noun:verb, all values get executed every
//             turn as instructions.
//
//
// The absolute minimum is:
// [<STORY>] [:begin] [!noun:verb]
// This will be called when starting the story and will tell the reader to go to
// verb in noun and execute that block.
//
// ******** Function calls *********** name()
//
// [!function(argument1, argument2)] - bare function call.
// Function calls can also be used wherever a value can be used.
//
// The arguments are values so you can do execution inside the arguments so
// both function(arg1 + arg2) and function(@noun) calls are legal.
//
// You can even evaluate a name of the function @noun1(@noun2). This will call
// all the functions with names matching the text values of noun1 and use
// values of noun2 as arguments.
//
// Play(asset) - returns true if played
// Stop(asset) - returns true if stopped
// Size(noun) - returns number of values of a noun (not counting the integer)
// List(noun) - prints a list of text values as keywords (like so: <n1>, <n2>)
//
// ******** Media Assets ************* [$ = type()]
//
// [$asset=type(parameter1, parameter2)] - creates an image, sound etc.
// Asseet definitions need to be outside noun definitions and start on a new
// line. No breaklines allowed within definition. These are not function calls.
//
// Each needs a unique name and only one instance of each is allowed. Calling
// Play again will play from beginning. Calling Stop on a stopped asset is safe.
//
// Supported types are:
// BG(filename) - background, always to fit the window and behind all else
// Image(filename, position x%, position y%, size x%, size y%)
// Music(filename) - sound that loops
// Voice(filename) - sound that plays once and only one voice at a time
//
//******************************************************************************

//***************** starting place, exits, inventory and tools *****************

[<BEGIN> = your room:go]
[<PLACE>] // we start nowhere
[<EXITS> = your room] //assign default value so we can enter our starting room
[<NOUNS>]
[<QUICK> = self:visible, self:list]
[<CALLS>]

//******************** background setting **************************************

[$bgroom=BG(bgroom.png)] // this creates an asset of type BG (background)
[$musicroom=Music(musicroom.ogg)]
[$voiceroom=Voice(voiceroom.ogg)]

[<your room media>]
  [:show]
    [!Play(bgroom)]
    [!Play(musicroom)]
    [!Play(voiceroom)]
    // [!calls+=your room media:autohide] // this gets evaluated each turn
  [:autohide] // and will hide the background if we leave
    [?@PLACE-=your room]
      [!calls-=your room media:autohide]
      [!Stop(bgroom)]
      [!Stop(musicroom)]
      // [!Stop(voiceroom)] voice is a one off so no need to stop

//******************************************************************************

[<self>]
  [:look]
    You are tired.
  [:list]
    \nInventory:\n
    [!List(self)] // show keywords for items we have
  [:visible]
    [!List(PLACE)] // show the keyword for the location we are in
    \nObjects:\n
    [!List(@PLACE)] // and all the things that are there

// These patterns are defined per story.
// This way you can define the game to work like a regular IF with places and
// an inventory.
//************************ pattern for places  *********************************

[<[room]>] // pattern definition because noun after [< is blank
           // we will store items here

// top level conditions are the ones placed above the verb definition
[?@EXITS+=room] & [?@PLACE-=room] { // both conditions need to be met
  [:go] // verb, this is where the excutions goes upon calling [!room:go]
    // these instruction get executed when room:go gets called,
    [!EXITS=] // this one clears exits
    [!PLACE=room] // change location to the room we're entering
    [!nouns]
    [!:look] // look at the room we're in now
}

[?@PLACE+=room] { // rest of the actions are available when we are in the room
  // this is a cheat, if there is no closing } it's assumed to be at the end
  // of the definition rather then at the next top level condition
  // rest gets appended here

//************************ pattern for items  **********************************

[<[item]>]

[?@@PLACE+=item] { // if the item is the location we are in
  [:take]
    [!@PLACE-=item]
    [!self+=item]
    Taken.

//******************************************************************************

[<pen[item]>]
  [:look]
    Black ink pen.

//******************************************************************************

[<your room[room]> = tea, pen] // noun definition for <your room>,
                               // uses the <room> definition as base

[:look] // because we appended the room definition these are only visible
        // when we're in the room
  You are sitting in your <room[your room]> <programming[program]>.
  A cup of <tea> is on the desk.
  [?+=pen] {
    A <pen> is lying on the desk.
  }
  The room has only one <door>.

  [?@door=open] // if the door is open
    [!EXITS+=staircase] // add the staircase as a possible exit
    You can see the <staircase> through the open <door>.

//******************************************************************************

[<door>] // noun definition, this ends the last block and starts a new one

[?-=open] // if the door is not open
  [:open] [:use] // only the first one is visible, but both will work
    You open the door. You may now exit to the <staircase>.
    [!EXITS+=staircase]
    [!door=open]

[?+=open] // if the door is open (door is implied)
  [:close] [:use] // this time use will close it
    You close the door.
    [!door=] // close it by clearing the open value from the door noun

  [:leave]
    [!staircase:go]
      You leave the room and enter the <staircase>.

//******************************************************************************

[<tea>]

[?-=empty] {
  [:look]
    [?-=warm]
      The <cup of tea[tea]> is getting cold.
    [?+=warm]
      The fresh <cup of tea[tea]> is nice and warm.

  [:drink] [:use]
    [?-=warm]
      You drink the cold tea, it's not very nice.
      [!+=empty]
    [?+=warm]
      Ahh, that hits the spot.
      [!+=empty]
}

[?+=empty] {
  [:look at] [:use]
    The cup of tea is empty.
}

[:make fresh]
  You make a fresh <cup of tea[tea]>.
  [!+=warm] [!-=empty]

//******************************************************************************

[<program>]

[:look]
  [!your room media:show]
  You are writing an interactive fiction engine.
  [?<=#1] {
    It's a long way to go.
    [!<<] // this aborts the execution of the parent block
          // so the next statement doesn't activate
  }
  [?<=#3] {
    Still needs a lot of work.
  }

[:program] [:use]
  You work for a few minutes.
  [!tea-=warm]
  [!=#program+#1+(#1+#1)+Size(program)]

//******************************************************************************

[<staircase[room]>]

[:look]
  You are outside your <room[your room]>.
  [!EXITS+=your room]
